---
title: 💻 自作言語インタプリタを作りたい4
date: 2018-8-8
tag: programming
---

# ただいま
今日は起きたら出勤時刻1時間前で記事を書く時間がなかったので5連勤目10時間シフトの後の投稿となりました。
疲れ果てて帰宅した後に部屋を薄暗くしてアロマ焚きながらVtuberの生放送をみるのが至高。


\#NowListening [バ美肉らじお　ばびらじ！　#1](https://youtu.be/TXDdewgf3Eo)


# それはさておきつづき

# 7/20(5日目)
型システムを少し拡張してタプルなどに対応しました。

### lambda.ac
```
a: Int -> Int = { i: Int -> i ^ 2 } // lambda
b: (Int, Int) = (1, 2) // tuple
```

ちなみに内部では `Int -> Int` は `[['Int'], 'Int']`、`(Int, Int)` は `[['Int', 'Int']]` という構造となっています。
しかし、タプルは型を複雑にしすぎるという理由で後々導入をやめました。

# 7/24(7日目)
```
commit 10003dc8eafb73721da2852d9f6800d7ccaab604 '式の評価をするTraverserを書き始めた'
```

パーサーと意味解析器を分離して、ASTを再帰的に辿るTraverserを書き始めました。例えば、

### sample.ac
```
a: = 1 + 1
```

は

### AST
```
['assign', ['decl', 'a', []], ['add', ['int_lit', 1, 'Int'], ['int_lit', 1, 'Int']]]
```

というASTが構築され、

### 意味解析器による評価の流れ
```
['decl', 'a', []] -> ['id', 'a', []]
['add', ['int_lit', 1, 'Int'], ['int_lit', 1, 'Int']] -> ['int_lit', 2, 'Int']
['assign', ['id', 'a', []], ['int_lit', 2, 'Int']]
['id', 'a', 'Int'] // a => 2
```

という流れで評価されます。余談ですが宣言時の `a` の型は `[]` 、つまり空なのですが代入時に左辺の型から推論しています。つまり型推論を備えているということです。このような単純なパターンだからかもしれませんが実装は全く難しくないので、すぐに実現できています。(ラムダ式の型推論とかやると難しそう)


眠いので寝ます。続きは起きたら書きます。では、