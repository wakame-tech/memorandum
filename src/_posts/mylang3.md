---
title: 自作言語インタプリタを作りたい3
date: 2018-08-06
tags: [言語処理系]
---

# バイトの疲れが溜まってきた
３日目です。バイトがつらいけど８月末で退職するのであと十数回行けば完全なる自由が手に入ると思うと頑張れる。
ところで、先日金欠ながらAmazonで[タブレットアーム](https://www.amazon.co.jp/gp/product/B071ZXQG7M/ref=oh_aui_detailpage_o00_s00?ie=UTF8&psc=1)をポチりました。ベッドに取り付けたら人間をダメにする機械の完成です。これでYoutubeとかアニメ鑑賞とかするのが最高すぎる。
2000円で人生が変わる(悪い方向に)のでおすすめのアイテムです。

# 閑話休題
コミットログを見ながらいままで何をしてきたのか振り返りたいと思います。

## 7/16(1日目)
この日から `Arcturus(注: 自作言語プロジェクトの名前)` の開発が始まっています。この日は確か大学が補講日で休日にも関わらず、レポート提出ついでにテスト勉強しに大学に赴いた日です。テスト勉強しろ。

言語を解析するにあたって大体は大まかに分けて次のステップを踏む必要があります。(インタプリタの場合)

### プログラム実行までの主な流れ
```
[字句解析] → [構文解析] → [意味解析] → [実行]
```

字句解析はソースコードを対応するトークンに置き換える作業です。これは正規表現で出来ます。
構文解析は字句解析で生成されたトークン列を構文の構造に落とし込みます。
これが難しそう、そんな時に見つけたのが `Ruby` の標準添付ライブラリ `racc` です。
`racc` は `Ruby` 版 `yacc` で、 `yacc` はパーサジェネレータの１つです。ここでは`racc`の使い方などは割愛しますが `yacc` によって構文解析を容易に行うことが出来ました。この日は簡単な四則演算の字句解析器と構文解析器を実装して終わり。

# 7/17(2日目)
```
commit 803dacd4ec204535c16b0a02cb57b78d02552eb3 '関数呼び出し複数引数時のカンマにめちゃ苦戦したけどゴリ押しでなんとかなった'
```

この日は `f(1, 2, 3, 4)` みたいなプログラムをパースしようと苦戦していたみたいです。結果ゴリ押しで

### parser.y
```
# 関数呼び出し
    parameters: 
         PAREN_OPEN exp PAREN_CLOSE { result = [val[1]] }
         | PAREN_OPEN exp COMMA exp PAREN_CLOSE { result = [val[1], val[3]] }
         | PAREN_OPEN exp COMMA exp COMMA exp PAREN_CLOSE { result = [val[1], val[3], val[5]] }
         | PAREN_OPEN exp COMMA exp COMMA exp COMMA exp PAREN_CLOSE { result = [val[1], val[3], val[5], val[7]] }
         | PAREN_OPEN exp COMMA exp COMMA exp COMMA exp COMMA exp PAREN_CLOSE { result = [val[1], val[3], val[5], val[7], val[9]] }
         | PAREN_OPEN exp COMMA exp COMMA exp COMMA exp COMMA exp COMMA exp PAREN_CLOSE { result = [val[1], val[3], val[5], val[7], val[9], val[11]] }
```

6引数までをべた書きにすることで対応したようです。(後日改良してます)


ていうかテスト勉強して。。

# 7/18(3日目)
この日は変数定義や関数定義の実装に取り組んでいたようです。
この頃はまだ構文解析器と意味解析器が分離されておらず、`racc` の `y` ファイルの中に直接変数が宣言されたときの処理とかを書いていたようです。


変数は名前空間のシンボルをキーとするハッシュで管理されていて、各キーに対応する値は変数名のシンボルをキーとするハッシュです。
例えば、

### decl.ac
```
a: Int
```

のような形で宣言された時に `global` 空間での `a` の宣言なので、 `var_table[:global][:a]` に変数の情報(型など)が格納されます。
こうすることによって関数の引数の変数名がグローバルで宣言されている変数名と被って使えないなどということが回避できます。
最初に思いついたのがこれだけどもっといい方法があるかも・・・。


次に関数、関数は単純に関数名をキーとするハッシュで管理されていてキーに対応する値は関数の情報(各引数の型、返り値型、関数の実装)が格納されます。

### fn.ac
```
fn f(a: Int) -> Int {
    a + 1
}
```


この時点では関数の戻り値は最後に評価された値を返すようにしています。ただまだ宣言された返り値型と実際の返り値の型が一致するかを検査していなかったりいろいろ荒削りです。

本日も時間が来てしまったので続きは明日となります。では、